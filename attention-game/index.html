<script>
/* ======================
   DOM REFERENCES
====================== */
const screen = document.getElementById("screen");
const title = document.getElementById("title");
const subtitle = document.getElementById("subtitle");
const form = document.getElementById("demographics");
const thankyou = document.getElementById("thankyou");

/* ======================
   STATE VARIABLES
====================== */
let state = 0;
let gameActive = false;
let startTime;
let currentLetter = "";
let letterStart = null;

let gameDuration = 10 * 60 * 1000; // 10 minutes

// Trial storage
let trials = [];

/* ======================
   INPUT HANDLING
====================== */
document.addEventListener("keydown", e => {
    if (e.code === "Space") {
        e.preventDefault();
        handleSpace();
    }
});

function handleSpace() {
    if (state === 0) showDirections();
    else if (state === 1) startGame();
    else if (gameActive) registerResponse();
}

/* ======================
   SCREENS
====================== */
function showDirections() {
    state = 1;
    title.textContent = "Directions";
    subtitle.innerHTML = `
        Pay attention to the letter shown on your screen.<br><br>
        The letter will change every few seconds.<br><br>
        Whenever the letter <strong>X</strong> appears,
        press the space bar as quickly as possible.<br><br>
        <span class="small">press space to continue</span>
    `;
}

function startGame() {
    state = 2;
    gameActive = true;
    startTime = performance.now();
    title.textContent = "";
    subtitle.textContent = "";
    runTrial();
}

/* ======================
   GAME LOGIC
====================== */
function runTrial() {
    if (performance.now() - startTime >= gameDuration) {
        endGame();
        return;
    }

    currentLetter = Math.random() < 0.2
        ? "X"
        : String.fromCharCode(65 + Math.floor(Math.random() * 26));

    letterStart = performance.now();

    trials.push({
        time: letterStart,
        letter: currentLetter,
        responded: false,
        reactionTime: null
    });

    title.textContent = currentLetter;

    setTimeout(() => {
        title.textContent = "";
        currentLetter = "";
        setTimeout(runTrial, (Math.floor(Math.random() * 3) + 1) * 1000);
    }, 250);
}

function registerResponse() {
    const lastTrial = trials[trials.length - 1];
    if (!lastTrial || lastTrial.responded) return;

    lastTrial.responded = true;

    if (lastTrial.letter === "X") {
        lastTrial.reactionTime = performance.now() - letterStart;
    }
}

/* ======================
   END GAME
====================== */
function endGame() {
    gameActive = false;
    screen.classList.add("hidden");
    form.classList.remove("hidden");

    const fields = form.querySelectorAll("input, textarea");
    fields[fields.length - 1].addEventListener("keydown", submitOnEnter);
}

/* ======================
   PERFORMANCE METRICS
====================== */
function computePerformance() {
    let correctX = 0;
    let correctIgnore = 0;
    let reactionTimes = [];

    trials.forEach(t => {
        if (t.letter === "X" && t.responded) {
            correctX++;
            reactionTimes.push(t.reactionTime);
        }
        if (t.letter !== "X" && !t.responded) {
            correctIgnore++;
        }
    });

    const accuracy =
        ((correctX + correctIgnore) / trials.length) * 100;

    const avgRT =
        reactionTimes.reduce((a, b) => a + b, 0) / reactionTimes.length;

    return { accuracy, avgRT };
}

/* ======================
   TREND CALCULATIONS
====================== */
function linearSlope(x, y) {
    const n = x.length;
    const mx = x.reduce((a,b)=>a+b,0) / n;
    const my = y.reduce((a,b)=>a+b,0) / n;

    let num = 0, den = 0;
    for (let i = 0; i < n; i++) {
        num += (x[i] - mx) * (y[i] - my);
        den += (x[i] - mx) ** 2;
    }
    return den === 0 ? 0 : num / den;
}

function computeTrends(blockMs = 60000) {
    let blocks = {};

    trials.forEach(t => {
        const block = Math.floor((t.time - trials[0].time) / blockMs);
        if (!blocks[block]) blocks[block] = [];
        blocks[block].push(t);
    });

    let time = [];
    let acc = [];
    let rt = [];

    Object.keys(blocks).forEach((b, i) => {
        let correct = 0;
        let rts = [];

        blocks[b].forEach(t => {
            if (t.letter === "X" && t.responded) {
                correct++;
                rts.push(t.reactionTime);
            }
            if (t.letter !== "X" && !t.responded) correct++;
        });

        time.push(i);
        acc.push(correct / blocks[b].length);
        rt.push(rts.length ? rts.reduce((a,b)=>a+b,0)/rts.length : null);
    });

    return {
        accuracyTrend: linearSlope(time, acc),
        reactionTrend: linearSlope(time, rt.map(v => v ?? rt[0]))
    };
}

/* ======================
   FORM SUBMISSION
====================== */
function submitOnEnter(e) {
    if (e.key === "Enter") {
        e.preventDefault();
        submitForm();
    }
}

function submitForm() {
    const perf = computePerformance();
    const trends = computeTrends();

    const data = new FormData(form);

    // ðŸ”½ REPLACE ENTRY IDS
    data.append("entry.ACCURACY_ID", perf.accuracy.toFixed(2));
    data.append("entry.RT_ID", perf.avgRT.toFixed(1));
    data.append("entry.ACC_TREND_ID", trends.accuracyTrend.toFixed(4));
    data.append("entry.RT_TREND_ID", trends.reactionTrend.toFixed(4));

    fetch("https://docs.google.com/forms/d/e/1FAIpQLSdVY3gTqkYRHXfqHcmA-AvBUbCaQJ5_Y79sMU7YvSd7adVyAg/formResponse", {
        method: "POST",
        mode: "no-cors",
        body: data
    });

    form.classList.add("hidden");
    thankyou.classList.remove("hidden");
}
</script>





